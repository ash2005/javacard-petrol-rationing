package ru.hwsec.teamara;

import java.nio.ByteBuffer;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.util.Calendar;
import java.util.Random;
import java.util.Scanner;

import javax.smartcardio.CardException;
import javax.smartcardio.CommandAPDU;
import javax.smartcardio.ResponseAPDU;

public class AraTerminal {

    private CardComm cardComm;

    private void execute() {
        /* INITIALISATION STATE */
        /*
        this.setPIN();
        this.pinCheck();
        this.pinCheck();
        */

        /* Issued State */
        try {
			this.performHandshake();
		} catch (CardException e) {
			System.out.println("Could not perform the handshake with the card.");
		}
    }


    /* Mutual Authentication Functions */

    private void performHandshake() throws CardException {
        ResponseAPDU resp;
        // We first generate 4 random bytes to send the card
        Random rnd = new Random(Calendar.getInstance().getTimeInMillis());
        byte[] termRndBytes = new byte[4];
        rnd.nextBytes(termRndBytes);

        // Send TERMINAL_HELLO and get back the CARD_HELLO answer containing 4 random bytes
        resp = this.cardComm.sendToCard(new CommandAPDU(0, Instruction.TERMINAL_HELLO, 0, 0, termRndBytes));
        byte[] cardRndBytes = resp.getData();
        System.out.println(cardRndBytes.length);

        // Send the public key of the terminal with the signature
        // 51 bytes (0..50) public key of the terminal
        // 54 bytes (51..104) signature of the key
        // Total: 105 bytes
        byte[] signedKey = new byte[105];
        System.arraycopy(ECCTerminal.PUBLIC_KEY_BYTES, 0, signedKey, 0, ECCTerminal.PUBLIC_KEY_BYTES.length);
        System.arraycopy(ECCTerminal.SIGNATURE_BYTES, 0, signedKey, ECCTerminal.PUBLIC_KEY_BYTES.length, ECCTerminal.SIGNATURE_BYTES.length);
        // P1 specifies what type of terminal this is:
        // P1 = 1 ==> charging terminal
        // P1 = 2 ==> pump terminal
        resp = this.cardComm.sendToCard(new CommandAPDU(0, Instruction.TERMINAL_KEY, 1, 0, signedKey));
        byte[] data = resp.getData();

        // Verify the public key and signature received from the card
        byte[] cardKeyBytes = new byte[51];
        byte[] cardSignatureBytes = new byte[54];
        System.arraycopy(data, 0, cardKeyBytes, 0, 51);
        System.arraycopy(data, 51, cardSignatureBytes, 0, 54);
        try {
			ECCTerminal.verifyCardKey(cardKeyBytes, cardSignatureBytes);
		} catch (GeneralSecurityException e) {
			System.out.println("An error occured while verifying the card key.");
		}

		// Generate DH Secret
        resp = this.cardComm.sendToCard(new CommandAPDU(0, Instruction.GEN_SHARED_SECRET, 1, 0));
        byte[] cardSecret = resp.getData();
		System.out.printf("The DH Secret generated by the card is of byte length: ");
		System.out.println(cardSecret.length);
		if (cardSecret.length == 1){
			System.out.println(String.format("0x%02X", cardSecret[0]));
		}

    }

    /* PIN Functions */

    public void setPIN() throws CardException {
    	System.out.print("INITIALISATION: Please choose a strong PIN Code");
    	byte pincode[] = ask_for_PIN();

        ResponseAPDU resp;
        resp = this.cardComm.sendToCard(new CommandAPDU(0, Instruction.SET_PIN, 0, 0, pincode));
        /*
        byte[] cardRndBytes = resp.getData();
        System.out.println(cardRndBytes.length);

        for (byte b :  cardRndBytes)
        	System.out.format("0x%x ", b);
        System.out.println();
        */
    }

    public boolean pinCheck() throws CardException{
    	byte pincode[] = ask_for_PIN();
        ResponseAPDU resp;
        // Send TERMINAL_HELLO and get back the CARD_HELLO answer containing 4 random bytes
        resp = this.cardComm.sendToCard(new CommandAPDU(0, Instruction.CHECK_PIN, 0, 0, pincode));
        byte[] cardRndBytes = resp.getData();
        /*System.out.println(cardRndBytes.length);
        for (byte b :  cardRndBytes)
        	System.out.format("0x%x ", b);
        System.out.println();*/
        if(cardRndBytes[0] == 0x01)
        		System.out.println("Correct PIN");
        else{
        		System.out.println("Wrong PIN");
        		System.out.printf("Tries Remaining: ");
        		System.out.println(cardRndBytes[1]);
        }
        return true;
    }


    // Asks user for PIN and returns the byte array.
    private byte [] ask_for_PIN(){
    	String input = null;
    	byte[] bytes = ByteBuffer.allocate(4).putInt(1111).array(); // initialize

        System.out.println("");
        System.out.print("Enter PIN: ");
        Scanner in = new Scanner( System.in );

        try{
        	input = in.next();
        	int pin = Integer.parseInt(input); // Just to check if it is an integer, var is not used.


        	int i = 0;
        	for(char charUserOutput : String.valueOf(input).toCharArray())
        	{
            	 bytes[i] = (byte) charUserOutput;
            	 i++;
        	}
        	/*
            for (byte b : bytes)
            {
            	System.out.format("0x%x ", b);
            }
            System.out.println();
            */

        } catch(NumberFormatException e) {
        	System.out.println("Input is not a number");
        	System.exit(1);
        } catch (Exception e) {
            System.out.println("IO error.");
            System.exit(1);
        }
        return bytes;
    }

    public static void main(String[] arg) {
    	AraTerminal araTerminal = new AraTerminal();
        try {
			araTerminal.cardComm = new CardComm(true);
		} catch (CardException e) {
			System.out.println("Could not connect to the card or simulator.");
		}
    	araTerminal.execute();
    }
}
