As specified in the previous chapter, the mutual authentication and sharing of secrets will be done with the use of a CA based on three tiers. Because of the fact that the JavaCard API does not have dedicated classes for the X.509 format, we decided to strip down the system to it's core components and use those primitives directly. As a result, the card will only store private and public keys and distinct signatures of each public key in order to make the keypair valid. No extra information which is stored in regular certificates (e.g. common name) will be available on the devices.

The initial data exchange between a card and a terminal (either of the two terminal types) is meant to authenticate the devices to one another and establish a secure communication channel. For this purpose, we attempted to simulate the functionality of the TLS protocol which consists of validating both certificates. The steps of this initial handshake are as follows:
\begin{enumerate}
 \item The card sends to the terminal an initial CARD-HELLO message which includes a random nonce.
 \item The terminal receives the CARD-HELLO message and sends back a TERMINAL-HELLO message which includes a different nonce. Subsequently, the terminal also sends to the card its public key, a timestamp indicating the date when the keypair was generated and a signature of the two items. The signature is made using the private key of the responsible intermediate certificate depending on the type of the terminal.
 \item After receiving the data from the terminal, the card verifies the signature against the stored public keys and in this way also checks what type of terminal it is communicating with. If the signature matches, then it proceeds to verify the associated timestamp. If this is also correct, then the card sends to the terminal its own public key, the timestamp when it was generated and a signature of the two items.
 \item The terminal receives the data and does the same verification as in the previous step. If the verification is passed, the terminal sends a CHANGE-CIPHER-SPEC message to the card, indicating that from then onwards all transmitted data will be encrypted.
 \item The card receives this message and sends its own CHANGE-CIPHER-SPEC.
 \item The two devices compute the same shared secret using the Diffie-Hellman key exchange algorithm. We will not be using the ephemeral version of the algorithm, but instead will use the same public and private keys of the devices. Since the algorithm requires that both parties have the appropriate private keys, the mutual authentication is established when both devices compute the same shared secret. This is the authenticated Diffie-Hellman key exchange algorithm.
 \item After the shared secret has been calculated, a pseudo-random function is used together with the two exchanged nonces and the shared secret to generate keys for encryption and message authentication codes.
\end{enumerate}

Once these steps have occured, the two devices have the assurance about each other's identity and can communicate via a secure channel.
