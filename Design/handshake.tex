As specified in the previous chapter, the mutual authentication and sharing of secrets will be done using CAs based on three tiers. Due to the fact that the JavaCard API does not have dedicated classes for the X.509 format, striping down the system to its core components and use those primitives directly is the only alternative. As a result, the card will only store private-public keys, expiry date, the unique serial number and the signatures of the intermediate CA over these information to certify their validity. No extra information which is stored in regular certificates (e.g. common name) will be available on the devices.

The initial data exchange between a card and a terminal (either of the two terminal types) is meant to authenticate the devices to one another and establish a secure communication channel. For this purpose, we attempted to simulate the functionality of the TLS protocol (specifically ECDH-ECDSA). 

The steps of this initial handshake are as follows:
\begin{enumerate}
 \item The terminal sends to the card an initial TERMINAL-HELLO message which includes a random nonce.
 \item The card receives the TERMINAL-HELLO message and sends back a CARD-HELLO message which includes a different nonce.
 \item The terminal sends to the card its public key and a signature of it and informs the card what type of terminal it is. The signature is made using the private key of the responsible intermediate certificate depending on the type of the terminal. The terminal does not send a timestamp since the card cannot accurately hold time on its own.
 \item After receiving the data from the terminal, the card verifies the signature against the stored public keys and in this way also verifies the type of terminal it is communicating with. If the signature matches, then the card sends to the terminal its own public key, the stored timestamp when the card's keypair expires and a signature of the two items. The trust store of the card contains the two public keys of the intermediate certificates used for the terminals. The public key of the root certificate is not used for verification purposes. The reason for this is that (a) for the root certificate we use keys much bigger than what the card supports, and (b) also to reduce the processing time required for signature verification.
 \item The terminal receives the data and verifies it accordingly. If the verification is passed, the terminal sends a CHANGE-CIPHER-SPEC message to the card, indicating that from then onwards all transmitted data will be encrypted.
 \item The card receives this message and sends its own CHANGE-CIPHER-SPEC.
 \item The two devices compute the same shared secret using the Diffie-Hellman key exchange algorithm. We will not be using the ephemeral version of the algorithm, but instead will use the static public and private keys of the devices. Since the algorithm requires that both parties have the appropriate private keys, the mutual authentication is established when both devices compute the same shared secret. This is the authenticated Diffie-Hellman key exchange algorithm which guards against MITM attack.
 \item After the shared secret has been calculated, a pseudo-random function is used together with the two exchanged nonces and the shared secret to generate keys for encryption and message authentication codes. These nonces help to ensure that the keys used are fresh, thus preventing replay attacks.
\end{enumerate}

Once these steps have occurred, the two devices have the assurance about each other's identity and can communicate via a confidential and authenticated channel.