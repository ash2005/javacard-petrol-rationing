As specified in the previous chapter, the mutual authentication and sharing of secrets will be done with the use of a CA based on three tiers. Because of the fact that the JavaCard API does not have dedicated classes for the X.509 format, we decided to strip down the system to it's core components and use those primitives directly. As a result, the card will only store private and public keys and distinct signatures of each public key in order to make the keypair valid. No extra information which is stored in regular certificates (e.g. common name) will be available on the devices.

The initial data exchange between a card and a terminal (either of the two terminal types) is meant to authenticate the devices to one another and establish a secure communication channel. For this purpose, we attempted to simulate the functionality of the TLS protocol which consists of validating both certificates. The steps of this initial handshake are as follows:
\begin{enumerate}
 \item The card sends to the terminal an initial CARD-HELLO message which includes a random nonce.
 \item The terminal receives the CARD-HELLO message and sends back a TERMINAL-HELLO message which includes a different nonce. Subsequently, the terminal also sends to the card its public key and a signature of it and informs the card what type of terminal it is. The signature is made using the private key of the responsible intermediate certificate depending on the type of the terminal. The terminal does not send a timestamp since the card cannot accurately hold time on its own.
 \item After receiving the data from the terminal, the card verifies the signature against the stored public keys and in this way also verifies the type of terminal it is communicating with. If the signature matches, then the card sends to the terminal its own public key, the stored timestamp when the card's keypair expires and a signature of the two items. The trust store of the card contains the two public keys of the intermediate certificates used for the terminals. The public key of the root certificate is not used for verification purposes. The reason for this is that for the root certificate we use keys much bigger than what the card supports.
 \item The terminal receives the data and verifies it accordingly. If the verification is passed, the terminal sends a CHANGE-CIPHER-SPEC message to the card, indicating that from then onwards all transmitted data will be encrypted.
 \item The card receives this message and sends its own CHANGE-CIPHER-SPEC.
 \item The two devices compute the same shared secret using the Diffie-Hellman key exchange algorithm. We will not be using the ephemeral version of the algorithm, but instead will use the same public and private keys of the devices. Since the algorithm requires that both parties have the appropriate private keys, the mutual authentication is established when both devices compute the same shared secret. This is the authenticated Diffie-Hellman key exchange algorithm.
 \item After the shared secret has been calculated, a pseudo-random function is used together with the two exchanged nonces and the shared secret to generate keys for encryption and message authentication codes.
\end{enumerate}

Once these steps have occured, the two devices have the assurance about each other's identity and can communicate via a secure channel.
